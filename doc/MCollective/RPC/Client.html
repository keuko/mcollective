<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class MCollective::RPC::Client - mcollective version 2.12.0</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
</script>

<script src="../../js/jquery.js"></script>
<script src="../../js/darkfish.js"></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link"><a href="../../Object.html">Object</a>
  
</div>

    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-i-agent_filter">#agent_filter</a>
    
    <li ><a href="#method-i-aggregate_reply">#aggregate_reply</a>
    
    <li ><a href="#method-i-batch_size-3D">#batch_size=</a>
    
    <li ><a href="#method-i-batch_sleep_time-3D">#batch_sleep_time=</a>
    
    <li ><a href="#method-i-call_agent">#call_agent</a>
    
    <li ><a href="#method-i-call_agent_batched">#call_agent_batched</a>
    
    <li ><a href="#method-i-class_filter">#class_filter</a>
    
    <li ><a href="#method-i-collective-3D">#collective=</a>
    
    <li ><a href="#method-i-compound_filter">#compound_filter</a>
    
    <li ><a href="#method-i-custom_request">#custom_request</a>
    
    <li ><a href="#method-i-detect_and_set_stdin_discovery">#detect_and_set_stdin_discovery</a>
    
    <li ><a href="#method-i-disconnect">#disconnect</a>
    
    <li ><a href="#method-i-discover">#discover</a>
    
    <li ><a href="#method-i-discovery_method-3D">#discovery_method=</a>
    
    <li ><a href="#method-i-discovery_options-3D">#discovery_options=</a>
    
    <li ><a href="#method-i-discovery_timeout">#discovery_timeout</a>
    
    <li ><a href="#method-i-discovery_timeout-3D">#discovery_timeout=</a>
    
    <li ><a href="#method-i-fact_filter">#fact_filter</a>
    
    <li ><a href="#method-i-fire_and_forget_request">#fire_and_forget_request</a>
    
    <li ><a href="#method-i-help">#help</a>
    
    <li ><a href="#method-i-identity_filter">#identity_filter</a>
    
    <li ><a href="#method-i-identity_filter_discovery_optimization">#identity_filter_discovery_optimization</a>
    
    <li ><a href="#method-i-limit_method-3D">#limit_method=</a>
    
    <li ><a href="#method-i-limit_targets-3D">#limit_targets=</a>
    
    <li ><a href="#method-i-load_aggregate_functions">#load_aggregate_functions</a>
    
    <li ><a href="#method-i-method_missing">#method_missing</a>
    
    <li ><a href="#method-i-new_request">#new_request</a>
    
    <li ><a href="#method-i-options">#options</a>
    
    <li ><a href="#method-i-pick_nodes_from_discovered">#pick_nodes_from_discovered</a>
    
    <li ><a href="#method-i-process_results_with_block">#process_results_with_block</a>
    
    <li ><a href="#method-i-process_results_without_block">#process_results_without_block</a>
    
    <li ><a href="#method-i-reset">#reset</a>
    
    <li ><a href="#method-i-reset_filter">#reset_filter</a>
    
    <li ><a href="#method-i-rpc_result_from_reply">#rpc_result_from_reply</a>
    
    <li ><a href="#method-i-validate_request">#validate_request</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-MCollective::RPC::Client">
  <h1 id="class-MCollective::RPC::Client" class="class">
    class MCollective::RPC::Client
  </h1>

  <section class="description">
    
<p>The main component of the Simple <a href="../RPC.html">RPC</a> client
system, this wraps around <a href="../Client.html">MCollective::Client</a>
and just brings in a lot of convention and standard approached.</p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    
    <section class="attribute-method-details" class="method-section">
      <header>
        <h3>Attributes</h3>
      </header>

      
      <div id="attribute-i-agent" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">agent</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-batch_mode" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">batch_mode</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-batch_size" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">batch_size</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-batch_sleep_time" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">batch_sleep_time</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-client" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">client</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-config" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">config</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-ddl" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">ddl</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-default_discovery_method" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">default_discovery_method</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-discovery_method" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">discovery_method</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-discovery_options" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">discovery_options</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-filter" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">filter</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-limit_method" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">limit_method</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-limit_seed" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">limit_seed</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-limit_targets" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">limit_targets</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-output_format" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">output_format</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-progress" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">progress</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-reply_to" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">reply_to</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-stats" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">stats</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-timeout" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">timeout</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-ttl" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">ttl</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
      <div id="attribute-i-verbose" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">verbose</span><span
            class="attribute-access-type">[RW]</span>
        </div>

        <div class="method-description">
        
        
        
        </div>
      </div>
      
    </section>
    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">(agent, flags = {}) { |parser, opts| ... }</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Creates a stub for a remote agent, you can pass in an options array in the
flags which will then be used else it will just create a default options
array with filtering enabled based on the standard command line use.</p>

<pre class="ruby"><span class="ruby-identifier">rpc</span> = <span class="ruby-constant">RPC</span><span class="ruby-operator">::</span><span class="ruby-constant">Client</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;rpctest&quot;</span>, :<span class="ruby-identifier">configfile</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;client.cfg&quot;</span>, :<span class="ruby-identifier">options</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">options</span>)
</pre>

<p>You typically would not call this directly you&#39;d use <a
href="../RPC.html#method-i-rpcclient">MCollective::RPC#rpcclient</a>
instead which is a wrapper around this that can be used as a Mixin</p>
          
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">agent</span>, <span class="ruby-identifier">flags</span> = {})
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">flags</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-value">:options</span>)
    <span class="ruby-identifier">initial_options</span> = <span class="ruby-identifier">flags</span>[<span class="ruby-value">:options</span>]

  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">@@initial_options</span>
    <span class="ruby-identifier">initial_options</span> = <span class="ruby-constant">Marshal</span>.<span class="ruby-identifier">load</span>(<span class="ruby-identifier">@@initial_options</span>)

  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">oparser</span> = <span class="ruby-constant">MCollective</span><span class="ruby-operator">::</span><span class="ruby-constant">Optionparser</span>.<span class="ruby-identifier">new</span>({ <span class="ruby-value">:verbose</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span>,
                                              <span class="ruby-value">:progress_bar</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>,
                                              <span class="ruby-value">:mcollective_limit_targets</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span>,
                                              <span class="ruby-value">:batch_size</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">nil</span>,
                                              <span class="ruby-value">:batch_sleep_time</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span> },
                                            <span class="ruby-string">&quot;filter&quot;</span>)

    <span class="ruby-identifier">initial_options</span> = <span class="ruby-identifier">oparser</span>.<span class="ruby-identifier">parse</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">parser</span>, <span class="ruby-identifier">opts</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
        <span class="ruby-keyword">yield</span>(<span class="ruby-identifier">parser</span>, <span class="ruby-identifier">opts</span>)
      <span class="ruby-keyword">end</span>

      <span class="ruby-constant">Helpers</span>.<span class="ruby-identifier">add_simplerpc_options</span>(<span class="ruby-identifier">parser</span>, <span class="ruby-identifier">opts</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">@@initial_options</span> = <span class="ruby-constant">Marshal</span>.<span class="ruby-identifier">dump</span>(<span class="ruby-identifier">initial_options</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-ivar">@initial_options</span> = <span class="ruby-identifier">initial_options</span>

  <span class="ruby-ivar">@config</span> = <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:config</span>]
  <span class="ruby-ivar">@client</span> = <span class="ruby-constant">MCollective</span><span class="ruby-operator">::</span><span class="ruby-constant">Client</span>.<span class="ruby-identifier">new</span>(<span class="ruby-ivar">@initial_options</span>)

  <span class="ruby-ivar">@stats</span> = <span class="ruby-constant">Stats</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-ivar">@agent</span> = <span class="ruby-identifier">agent</span>
  <span class="ruby-ivar">@timeout</span> = <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:timeout</span>] <span class="ruby-operator">||</span> <span class="ruby-value">5</span>
  <span class="ruby-ivar">@verbose</span> = <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:verbose</span>]
  <span class="ruby-ivar">@filter</span> = <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:filter</span>] <span class="ruby-operator">||</span> <span class="ruby-constant">Util</span>.<span class="ruby-identifier">empty_filter</span>
  <span class="ruby-ivar">@discovered_agents</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@progress</span> = <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:progress_bar</span>]
  <span class="ruby-ivar">@limit_targets</span> = <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:mcollective_limit_targets</span>]
  <span class="ruby-ivar">@limit_method</span> = <span class="ruby-constant">Config</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">rpclimitmethod</span>
  <span class="ruby-ivar">@limit_seed</span> = <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:limit_seed</span>] <span class="ruby-operator">||</span> <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@output_format</span> = <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:output_format</span>] <span class="ruby-operator">||</span> <span class="ruby-value">:console</span>
  <span class="ruby-ivar">@force_direct_request</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-ivar">@reply_to</span> = <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:reply_to</span>]
  <span class="ruby-ivar">@discovery_method</span> = <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:discovery_method</span>]
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-ivar">@discovery_method</span>
    <span class="ruby-ivar">@discovery_method</span> = <span class="ruby-constant">Config</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">default_discovery_method</span>
    <span class="ruby-ivar">@default_discovery_method</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@default_discovery_method</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-ivar">@discovery_options</span> = <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:discovery_options</span>] <span class="ruby-operator">||</span> []
  <span class="ruby-ivar">@force_display_mode</span> = <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:force_display_mode</span>] <span class="ruby-operator">||</span> <span class="ruby-keyword">false</span>

  <span class="ruby-ivar">@batch_size</span> = <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:batch_size</span>] <span class="ruby-operator">||</span> <span class="ruby-constant">Config</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">default_batch_size</span>
  <span class="ruby-ivar">@batch_sleep_time</span> = <span class="ruby-constant">Float</span>(<span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:batch_sleep_time</span>] <span class="ruby-operator">||</span> <span class="ruby-constant">Config</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">default_batch_sleep_time</span>)
  <span class="ruby-ivar">@batch_mode</span> = <span class="ruby-identifier">determine_batch_mode</span>(<span class="ruby-ivar">@batch_size</span>)

  <span class="ruby-identifier">agent_filter</span> <span class="ruby-identifier">agent</span>

  <span class="ruby-ivar">@discovery_timeout</span> = <span class="ruby-ivar">@initial_options</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:disctimeout</span>, <span class="ruby-keyword">nil</span>) <span class="ruby-operator">||</span> <span class="ruby-constant">Config</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">discovery_timeout</span>

  <span class="ruby-ivar">@collective</span> = <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">collective</span>
  <span class="ruby-ivar">@ttl</span> = <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:ttl</span>] <span class="ruby-operator">||</span> <span class="ruby-constant">Config</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">ttl</span>
  <span class="ruby-ivar">@publish_timeout</span> = <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:publish_timeout</span>] <span class="ruby-operator">||</span> <span class="ruby-constant">Config</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">publish_timeout</span>
  <span class="ruby-ivar">@threaded</span> = <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:threaded</span>] <span class="ruby-operator">||</span> <span class="ruby-constant">Config</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">threaded</span>

  <span class="ruby-comment"># if we can find a DDL for the service override</span>
  <span class="ruby-comment"># the timeout of the client so we always magically</span>
  <span class="ruby-comment"># wait appropriate amounts of time.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># We add the discovery timeout to the ddl supplied</span>
  <span class="ruby-comment"># timeout as the discovery timeout tends to be tuned</span>
  <span class="ruby-comment"># for local network conditions and fact source speed</span>
  <span class="ruby-comment"># which would other wise not be accounted for and</span>
  <span class="ruby-comment"># some results might get missed.</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># We do this only if the timeout is the default 5</span>
  <span class="ruby-comment"># seconds, so that users cli overrides will still</span>
  <span class="ruby-comment"># get applied</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># DDLs are required, failure to find a DDL is fatal</span>
  <span class="ruby-ivar">@ddl</span> = <span class="ruby-constant">DDL</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">agent</span>)
  <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">ddl</span> = <span class="ruby-ivar">@ddl</span>
  <span class="ruby-ivar">@timeout</span> = <span class="ruby-ivar">@ddl</span>.<span class="ruby-identifier">meta</span>[<span class="ruby-value">:timeout</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">discovery_timeout</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@timeout</span> <span class="ruby-operator">==</span> <span class="ruby-value">5</span>

  <span class="ruby-comment"># allows stderr and stdout to be overridden for testing</span>
  <span class="ruby-comment"># but also for web apps that might not want a bunch of stuff</span>
  <span class="ruby-comment"># generated to actual file handles</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:stderr</span>]
    <span class="ruby-ivar">@stderr</span> = <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:stderr</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@stderr</span> = <span class="ruby-constant">STDERR</span>
    <span class="ruby-ivar">@stderr</span>.<span class="ruby-identifier">sync</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:stdout</span>]
    <span class="ruby-ivar">@stdout</span> = <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:stdout</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@stdout</span> = <span class="ruby-constant">STDOUT</span>
    <span class="ruby-ivar">@stdout</span>.<span class="ruby-identifier">sync</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:stdin</span>]
    <span class="ruby-ivar">@stdin</span> = <span class="ruby-identifier">initial_options</span>[<span class="ruby-value">:stdin</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@stdin</span> = <span class="ruby-constant">STDIN</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-agent_filter" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">agent_filter</span><span
            class="method-args">(agent)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Sets the agent filter</p>
          
          

          
          <div class="method-source-code" id="agent_filter-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 437</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">agent_filter</span>(<span class="ruby-identifier">agent</span>)
  <span class="ruby-ivar">@filter</span>[<span class="ruby-string">&quot;agent&quot;</span>] = <span class="ruby-ivar">@filter</span>[<span class="ruby-string">&quot;agent&quot;</span>] <span class="ruby-operator">|</span> [<span class="ruby-identifier">agent</span>]
  <span class="ruby-ivar">@filter</span>[<span class="ruby-string">&quot;agent&quot;</span>].<span class="ruby-identifier">compact!</span>
  <span class="ruby-identifier">reset</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-aggregate_reply" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">aggregate_reply</span><span
            class="method-args">(reply, aggregate)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="aggregate_reply-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 731</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">aggregate_reply</span>(<span class="ruby-identifier">reply</span>, <span class="ruby-identifier">aggregate</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">aggregate</span>

  <span class="ruby-identifier">aggregate</span>.<span class="ruby-identifier">call_functions</span>(<span class="ruby-identifier">reply</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">aggregate</span>
<span class="ruby-keyword">rescue</span> <span class="ruby-constant">Exception</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>
  <span class="ruby-constant">Log</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&quot;Failed to calculate aggregate summaries for reply from %s, calculating summaries disabled: %s: %s (%s)&quot;</span> <span class="ruby-operator">%</span> [<span class="ruby-identifier">reply</span>[<span class="ruby-value">:senderid</span>], <span class="ruby-identifier">e</span>.<span class="ruby-identifier">backtrace</span>.<span class="ruby-identifier">first</span>, <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span>, <span class="ruby-identifier">e</span>.<span class="ruby-identifier">class</span>])
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-batch_size-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">batch_size=</span><span
            class="method-args">(limit)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Sets the batch size, if the size is set to 0 that will disable batch mode</p>
          
          

          
          <div class="method-source-code" id="batch_size-3D-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 648</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">batch_size=</span>(<span class="ruby-identifier">limit</span>)
  <span class="ruby-keyword">unless</span> <span class="ruby-constant">Config</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">direct_addressing</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;Can only set batch size if direct addressing is supported&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">validate_batch_size</span>(<span class="ruby-identifier">limit</span>)

  <span class="ruby-ivar">@batch_size</span> = <span class="ruby-identifier">limit</span>
  <span class="ruby-ivar">@batch_mode</span> = <span class="ruby-identifier">determine_batch_mode</span>(<span class="ruby-ivar">@batch_size</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-batch_sleep_time-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">batch_sleep_time=</span><span
            class="method-args">(time)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="batch_sleep_time-3D-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 659</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">batch_sleep_time=</span>(<span class="ruby-identifier">time</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;Can only set batch sleep time if direct addressing is supported&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-constant">Config</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">direct_addressing</span>

  <span class="ruby-ivar">@batch_sleep_time</span> = <span class="ruby-constant">Float</span>(<span class="ruby-identifier">time</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-call_agent" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">call_agent</span><span
            class="method-args">(action, args, opts, disc=:auto, &block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Handles traditional calls to the remote agents with full stats blocks, non
blocks and everything else supported.</p>

<p>Other methods of calling the nodes can reuse this code by for example
specifying custom options and discovery data</p>
          
          

          
          <div class="method-source-code" id="call_agent-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 913</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">call_agent</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">opts</span>, <span class="ruby-identifier">disc</span>=<span class="ruby-value">:auto</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-comment"># Handle fire and forget requests and make sure</span>
  <span class="ruby-comment"># the :process_results value is set appropriately</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># specific reply-to requests should be treated like</span>
  <span class="ruby-comment"># fire and forget since the client will never get</span>
  <span class="ruby-comment"># the responses</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>[<span class="ruby-value">:process_results</span>] <span class="ruby-operator">==</span> <span class="ruby-keyword">false</span> <span class="ruby-operator">||</span> <span class="ruby-ivar">@reply_to</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">fire_and_forget_request</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">args</span>[<span class="ruby-value">:process_results</span>] = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Do discovery when no specific discovery array is given</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># If an array is given set the force_direct_request hint that</span>
  <span class="ruby-comment"># will tell the message object to be a direct request one</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">disc</span> <span class="ruby-operator">==</span> <span class="ruby-value">:auto</span>
    <span class="ruby-identifier">discovered</span> = <span class="ruby-identifier">discover</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@force_direct_request</span> = <span class="ruby-keyword">true</span> <span class="ruby-keyword">if</span> <span class="ruby-constant">Config</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">direct_addressing</span>
    <span class="ruby-identifier">discovered</span> = <span class="ruby-identifier">disc</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">req</span> = <span class="ruby-identifier">new_request</span>(<span class="ruby-identifier">action</span>.<span class="ruby-identifier">to_s</span>, <span class="ruby-identifier">args</span>)

  <span class="ruby-identifier">message</span> = <span class="ruby-constant">Message</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">req</span>, <span class="ruby-keyword">nil</span>, {<span class="ruby-value">:agent</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@agent</span>, <span class="ruby-value">:type</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:request</span>, <span class="ruby-value">:collective</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@collective</span>, <span class="ruby-value">:filter</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:filter</span>], <span class="ruby-value">:options</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">opts</span>})
  <span class="ruby-identifier">message</span>.<span class="ruby-identifier">discovered_hosts</span> = <span class="ruby-identifier">discovered</span>.<span class="ruby-identifier">clone</span>

  <span class="ruby-identifier">results</span> = []
  <span class="ruby-identifier">respcount</span> = <span class="ruby-value">0</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">discovered</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">message</span>.<span class="ruby-identifier">type</span> = <span class="ruby-value">:direct_request</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@force_direct_request</span>

    <span class="ruby-keyword">if</span> <span class="ruby-ivar">@progress</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">block_given?</span>
      <span class="ruby-identifier">twirl</span> = <span class="ruby-constant">Progress</span>.<span class="ruby-identifier">new</span>
      <span class="ruby-ivar">@stdout</span>.<span class="ruby-identifier">puts</span>
      <span class="ruby-ivar">@stdout</span>.<span class="ruby-identifier">print</span> <span class="ruby-identifier">twirl</span>.<span class="ruby-identifier">twirl</span>(<span class="ruby-identifier">respcount</span>, <span class="ruby-identifier">discovered</span>.<span class="ruby-identifier">size</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">aggregate</span> = <span class="ruby-identifier">load_aggregate_functions</span>(<span class="ruby-identifier">action</span>, <span class="ruby-ivar">@ddl</span>)

    <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">req</span>(<span class="ruby-identifier">message</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">resp</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">respcount</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>

      <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
        <span class="ruby-identifier">aggregate</span> = <span class="ruby-identifier">process_results_with_block</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">resp</span>, <span class="ruby-identifier">block</span>, <span class="ruby-identifier">aggregate</span>)
      <span class="ruby-keyword">else</span>
        <span class="ruby-ivar">@stdout</span>.<span class="ruby-identifier">print</span> <span class="ruby-identifier">twirl</span>.<span class="ruby-identifier">twirl</span>(<span class="ruby-identifier">respcount</span>, <span class="ruby-identifier">discovered</span>.<span class="ruby-identifier">size</span>) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@progress</span>

        <span class="ruby-identifier">result</span>, <span class="ruby-identifier">aggregate</span> = <span class="ruby-identifier">process_results_without_block</span>(<span class="ruby-identifier">resp</span>, <span class="ruby-identifier">action</span>, <span class="ruby-identifier">aggregate</span>)

        <span class="ruby-identifier">results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">result</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-ivar">@initial_options</span>[<span class="ruby-value">:sort</span>]
      <span class="ruby-identifier">results</span>.<span class="ruby-identifier">sort!</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">aggregate_summary</span> = <span class="ruby-identifier">aggregate</span>.<span class="ruby-identifier">summarize</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">aggregate</span>
    <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">aggregate_failures</span> = <span class="ruby-identifier">aggregate</span>.<span class="ruby-identifier">failed</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">aggregate</span>
    <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">client_stats</span> = <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">stats</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@stderr</span>.<span class="ruby-identifier">print</span>(<span class="ruby-string">&quot;\nNo request sent, we did not discover any nodes.&quot;</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">finish_request</span>

  <span class="ruby-constant">RPC</span>.<span class="ruby-identifier">stats</span>(<span class="ruby-ivar">@stats</span>)

  <span class="ruby-ivar">@stdout</span>.<span class="ruby-identifier">print</span>(<span class="ruby-string">&quot;\n\n&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@progress</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">stats</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">return</span> [<span class="ruby-identifier">results</span>].<span class="ruby-identifier">flatten</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-call_agent_batched" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">call_agent_batched</span><span
            class="method-args">(action, args, opts, batch_size, sleep_time, &block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Calls an agent in a way very similar to <a
href="Client.html#method-i-call_agent">#call_agent</a> but it supports
batching the queries to the network.</p>

<p>The result sets, stats, block handling etc is all exactly like you would
expect from normal call_agent.</p>

<p>This is used by <a
href="Client.html#method-i-method_missing">#method_missing</a> and works
only with direct addressing mode</p>
          
          

          
          <div class="method-source-code" id="call_agent_batched-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 808</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">call_agent_batched</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">opts</span>, <span class="ruby-identifier">batch_size</span>, <span class="ruby-identifier">sleep_time</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;Batched requests requires direct addressing&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-constant">Config</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">direct_addressing</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;Cannot bypass result processing for batched requests&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>[<span class="ruby-value">:process_results</span>] <span class="ruby-operator">==</span> <span class="ruby-keyword">false</span>
  <span class="ruby-identifier">validate_batch_size</span>(<span class="ruby-identifier">batch_size</span>)

  <span class="ruby-identifier">sleep_time</span> = <span class="ruby-constant">Float</span>(<span class="ruby-identifier">sleep_time</span>)

  <span class="ruby-constant">Log</span>.<span class="ruby-identifier">debug</span>(<span class="ruby-node">&quot;Calling #{agent}##{action} in batches of #{batch_size} with sleep time of #{sleep_time}&quot;</span>)

  <span class="ruby-ivar">@force_direct_request</span> = <span class="ruby-keyword">true</span>

  <span class="ruby-identifier">discovered</span> = <span class="ruby-identifier">discover</span>
  <span class="ruby-identifier">results</span> = []
  <span class="ruby-identifier">respcount</span> = <span class="ruby-value">0</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">discovered</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">req</span> = <span class="ruby-identifier">new_request</span>(<span class="ruby-identifier">action</span>.<span class="ruby-identifier">to_s</span>, <span class="ruby-identifier">args</span>)

    <span class="ruby-identifier">aggregate</span> = <span class="ruby-identifier">load_aggregate_functions</span>(<span class="ruby-identifier">action</span>, <span class="ruby-ivar">@ddl</span>)

    <span class="ruby-keyword">if</span> <span class="ruby-ivar">@progress</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">block_given?</span>
      <span class="ruby-identifier">twirl</span> = <span class="ruby-constant">Progress</span>.<span class="ruby-identifier">new</span>
      <span class="ruby-ivar">@stdout</span>.<span class="ruby-identifier">puts</span>
      <span class="ruby-ivar">@stdout</span>.<span class="ruby-identifier">print</span> <span class="ruby-identifier">twirl</span>.<span class="ruby-identifier">twirl</span>(<span class="ruby-identifier">respcount</span>, <span class="ruby-identifier">discovered</span>.<span class="ruby-identifier">size</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">batch_size</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/^(\d+)%$/</span>)
      <span class="ruby-comment"># determine batch_size as a percentage of the discovered array&#39;s size</span>
      <span class="ruby-identifier">batch_size</span> = (<span class="ruby-identifier">discovered</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">/</span> <span class="ruby-value">100.0</span> <span class="ruby-operator">*</span> <span class="ruby-constant">Integer</span>(<span class="ruby-node">$1</span>)).<span class="ruby-identifier">ceil</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">batch_size</span> = <span class="ruby-constant">Integer</span>(<span class="ruby-identifier">batch_size</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">requestid</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-identifier">processed_nodes</span> = <span class="ruby-value">0</span>

    <span class="ruby-identifier">discovered</span>.<span class="ruby-identifier">in_groups_of</span>(<span class="ruby-identifier">batch_size</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">hosts</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">message</span> = <span class="ruby-constant">Message</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">req</span>, <span class="ruby-keyword">nil</span>, {<span class="ruby-value">:agent</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@agent</span>,
                                       <span class="ruby-value">:type</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:direct_request</span>,
                                       <span class="ruby-value">:collective</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@collective</span>,
                                       <span class="ruby-value">:filter</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:filter</span>],
                                       <span class="ruby-value">:options</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">opts</span>})

      <span class="ruby-comment"># first time round we let the Message object create a request id</span>
      <span class="ruby-comment"># we then re-use it for future requests to keep auditing sane etc</span>
      <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">requestid</span> = <span class="ruby-identifier">message</span>.<span class="ruby-identifier">create_reqid</span> <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">requestid</span>
      <span class="ruby-identifier">message</span>.<span class="ruby-identifier">requestid</span> = <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">requestid</span>

      <span class="ruby-identifier">message</span>.<span class="ruby-identifier">discovered_hosts</span> = <span class="ruby-identifier">hosts</span>.<span class="ruby-identifier">clone</span>.<span class="ruby-identifier">compact</span>

      <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">req</span>(<span class="ruby-identifier">message</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">resp</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">respcount</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>

        <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
          <span class="ruby-identifier">aggregate</span> = <span class="ruby-identifier">process_results_with_block</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">resp</span>, <span class="ruby-identifier">block</span>, <span class="ruby-identifier">aggregate</span>)
        <span class="ruby-keyword">else</span>
          <span class="ruby-ivar">@stdout</span>.<span class="ruby-identifier">print</span> <span class="ruby-identifier">twirl</span>.<span class="ruby-identifier">twirl</span>(<span class="ruby-identifier">respcount</span>, <span class="ruby-identifier">discovered</span>.<span class="ruby-identifier">size</span>) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@progress</span>

          <span class="ruby-identifier">result</span>, <span class="ruby-identifier">aggregate</span> = <span class="ruby-identifier">process_results_without_block</span>(<span class="ruby-identifier">resp</span>, <span class="ruby-identifier">action</span>, <span class="ruby-identifier">aggregate</span>)

          <span class="ruby-identifier">results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">result</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-keyword">if</span> <span class="ruby-ivar">@initial_options</span>[<span class="ruby-value">:sort</span>]
        <span class="ruby-identifier">results</span>.<span class="ruby-identifier">sort!</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">noresponsefrom</span>.<span class="ruby-identifier">concat</span> <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">stats</span>[<span class="ruby-value">:noresponsefrom</span>]
      <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">unexpectedresponsefrom</span>.<span class="ruby-identifier">concat</span> <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">stats</span>[<span class="ruby-value">:unexpectedresponsefrom</span>]
      <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">responses</span> <span class="ruby-operator">+=</span> <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">stats</span>[<span class="ruby-value">:responses</span>]
      <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">blocktime</span> <span class="ruby-operator">+=</span> <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">stats</span>[<span class="ruby-value">:blocktime</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">sleep_time</span>
      <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">totaltime</span> <span class="ruby-operator">+=</span> <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">stats</span>[<span class="ruby-value">:totaltime</span>]
      <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">discoverytime</span> <span class="ruby-operator">+=</span> <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">stats</span>[<span class="ruby-value">:discoverytime</span>]

      <span class="ruby-identifier">processed_nodes</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">hosts</span>.<span class="ruby-identifier">length</span>
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">discovered</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">processed_nodes</span>)
        <span class="ruby-identifier">sleep</span> <span class="ruby-identifier">sleep_time</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">aggregate_summary</span> = <span class="ruby-identifier">aggregate</span>.<span class="ruby-identifier">summarize</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">aggregate</span>
    <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">aggregate_failures</span> = <span class="ruby-identifier">aggregate</span>.<span class="ruby-identifier">failed</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">aggregate</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@stderr</span>.<span class="ruby-identifier">print</span>(<span class="ruby-string">&quot;\nNo request sent, we did not discover any nodes.&quot;</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">finish_request</span>

  <span class="ruby-constant">RPC</span>.<span class="ruby-identifier">stats</span>(<span class="ruby-ivar">@stats</span>)

  <span class="ruby-ivar">@stdout</span>.<span class="ruby-identifier">print</span>(<span class="ruby-string">&quot;\n&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@progress</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">stats</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">return</span> [<span class="ruby-identifier">results</span>].<span class="ruby-identifier">flatten</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-class_filter" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">class_filter</span><span
            class="method-args">(klass)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Sets the class filter</p>
          
          

          
          <div class="method-source-code" id="class_filter-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 413</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">class_filter</span>(<span class="ruby-identifier">klass</span>)
  <span class="ruby-ivar">@filter</span>[<span class="ruby-string">&quot;cf_class&quot;</span>] = <span class="ruby-ivar">@filter</span>[<span class="ruby-string">&quot;cf_class&quot;</span>] <span class="ruby-operator">|</span> [<span class="ruby-identifier">klass</span>]
  <span class="ruby-ivar">@filter</span>[<span class="ruby-string">&quot;cf_class&quot;</span>].<span class="ruby-identifier">compact!</span>
  <span class="ruby-identifier">reset</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-collective-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">collective=</span><span
            class="method-args">(c)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Sets the collective we are communicating with</p>
          
          

          
          <div class="method-source-code" id="collective-3D-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 607</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">collective=</span>(<span class="ruby-identifier">c</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;Unknown collective #{c}&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-constant">Config</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">collectives</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">c</span>)

  <span class="ruby-ivar">@collective</span> = <span class="ruby-identifier">c</span>
  <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">options</span> = <span class="ruby-identifier">options</span>
  <span class="ruby-identifier">reset</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-compound_filter" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">compound_filter</span><span
            class="method-args">(filter)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Set a compound filter</p>
          
          

          
          <div class="method-source-code" id="compound_filter-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 451</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">compound_filter</span>(<span class="ruby-identifier">filter</span>)
  <span class="ruby-ivar">@filter</span>[<span class="ruby-string">&quot;compound&quot;</span>] = <span class="ruby-ivar">@filter</span>[<span class="ruby-string">&quot;compound&quot;</span>] <span class="ruby-operator">|</span>  [<span class="ruby-constant">Matcher</span>.<span class="ruby-identifier">create_compound_callstack</span>(<span class="ruby-identifier">filter</span>)]
  <span class="ruby-identifier">reset</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-custom_request" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">custom_request</span><span
            class="method-args">(action, args, expected_agents, filter = {}, &block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Constructs custom requests with custom filters and discovery data the idea
is that this would be used in web applications where you might be using a
cached copy of data provided by a registration agent to figure out on your
own what nodes will be responding and what your filter would be.</p>

<p>This will help you essentially short circuit the traditional cycle of:</p>

<p>mc discover / call / wait for discovered nodes</p>

<p>by doing discovery however you like, contructing a filter and a list of
nodes you expect responses from.</p>

<p>Other than that it will work exactly like a normal call, blocks will behave
the same way, stats will be handled the same way etcetc</p>

<p>If you just wanted to contact one machine for example with a client that
already has other filter options setup you can do:</p>

<p>puppet.custom_request(runonce, {}, [your.box.com], {:identity =&gt;
your.box.com})</p>

<p>This will do runonce action on just &#39;your.box.com&#39;, no discovery
will be done and after receiving just one response it will stop waiting for
responses</p>

<p>If direct_addressing is enabled in the config file you can provide an empty
hash as a filter, this will force that request to be a directly addressed
request which technically does not need filters.  If you try to use this
mode with direct addressing disabled an exception will be raise</p>
          
          

          
          <div class="method-source-code" id="custom_request-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 311</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">custom_request</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">expected_agents</span>, <span class="ruby-identifier">filter</span> = {}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">validate_request</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">filter</span> <span class="ruby-operator">==</span> {} <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-constant">Config</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">direct_addressing</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;Attempted to do a filterless custom_request without direct_addressing enabled, preventing unexpected call to all nodes&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">reset</span>

  <span class="ruby-identifier">custom_filter</span> = <span class="ruby-constant">Util</span>.<span class="ruby-identifier">empty_filter</span>
  <span class="ruby-identifier">custom_options</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">clone</span>

  <span class="ruby-comment"># merge the supplied filter with the standard empty one</span>
  <span class="ruby-comment"># we could just use the merge method but I want to be sure</span>
  <span class="ruby-comment"># we dont merge in stuff that isnt actually valid</span>
  [<span class="ruby-string">&quot;identity&quot;</span>, <span class="ruby-string">&quot;fact&quot;</span>, <span class="ruby-string">&quot;agent&quot;</span>, <span class="ruby-string">&quot;cf_class&quot;</span>, <span class="ruby-string">&quot;compound&quot;</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ftype</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">filter</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">ftype</span>)
      <span class="ruby-identifier">custom_filter</span>[<span class="ruby-identifier">ftype</span>] = [<span class="ruby-identifier">filter</span>[<span class="ruby-identifier">ftype</span>], <span class="ruby-identifier">custom_filter</span>[<span class="ruby-identifier">ftype</span>]].<span class="ruby-identifier">flatten</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># ensure that all filters at least restrict the call to the agent we&#39;re a proxy for</span>
  <span class="ruby-identifier">custom_filter</span>[<span class="ruby-string">&quot;agent&quot;</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-ivar">@agent</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">custom_filter</span>[<span class="ruby-string">&quot;agent&quot;</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-ivar">@agent</span>)
  <span class="ruby-identifier">custom_options</span>[<span class="ruby-value">:filter</span>] = <span class="ruby-identifier">custom_filter</span>

  <span class="ruby-comment"># Fake out the stats discovery would have put there</span>
  <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">discovered_agents</span>([<span class="ruby-identifier">expected_agents</span>].<span class="ruby-identifier">flatten</span>)

  <span class="ruby-comment"># Handle fire and forget requests</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># If a specific reply-to was set then from the client perspective this should</span>
  <span class="ruby-comment"># be a fire and forget request too since no response will ever reach us - it</span>
  <span class="ruby-comment"># will go to the reply-to destination</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>[<span class="ruby-value">:process_results</span>] <span class="ruby-operator">==</span> <span class="ruby-keyword">false</span> <span class="ruby-operator">||</span> <span class="ruby-ivar">@reply_to</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">fire_and_forget_request</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">custom_filter</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Now do a call pretty much exactly like in method_missing except with our own</span>
  <span class="ruby-comment"># options and discovery magic</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-identifier">call_agent</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">custom_options</span>, [<span class="ruby-identifier">expected_agents</span>].<span class="ruby-identifier">flatten</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">block</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">r</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">call_agent</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">custom_options</span>, [<span class="ruby-identifier">expected_agents</span>].<span class="ruby-identifier">flatten</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-detect_and_set_stdin_discovery" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">detect_and_set_stdin_discovery</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Detects data on STDIN and sets the STDIN discovery method</p>

<p>IF the discovery method hasn&#39;t been explicitly overridden</p>

<pre>and we&#39;re not being run interactively,
and someone has piped us some data</pre>

<p>Then we assume it&#39;s a discovery list - this can be either:</p>

<pre>- list of hosts in plaintext
- JSON that came from another rpc or printrpc</pre>

<p>Then we override discovery to try to grok the data on STDIN</p>
          
          

          
          <div class="method-source-code" id="detect_and_set_stdin_discovery-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 479</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">detect_and_set_stdin_discovery</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">default_discovery_method</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-ivar">@stdin</span>.<span class="ruby-identifier">tty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-ivar">@stdin</span>.<span class="ruby-identifier">eof?</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">discovery_method</span> = <span class="ruby-string">&#39;stdin&#39;</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">discovery_options</span> = <span class="ruby-string">&#39;auto&#39;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-disconnect" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">disconnect</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Disconnects cleanly from the middleware</p>
          
          

          
          <div class="method-source-code" id="disconnect-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">disconnect</span>
  <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">disconnect</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-discover" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">discover</span><span
            class="method-args">(flags={})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Does discovery based on the filters set, if a discovery was previously done
return that else do a new discovery.</p>

<p>Alternatively if identity filters are given and none of them are regular
expressions then just use the provided data as discovered data, avoiding
discovery</p>

<p><a href="../Discovery.html">Discovery</a> can be forced if
direct_addressing is enabled by passing in an array of nodes with :nodes or
JSON data like those produced by mcollective <a href="../RPC.html">RPC</a>
JSON output using :json</p>

<p>Will show a message indicating its doing discovery if running verbose or if
the :verbose flag is passed in.</p>

<p>Use reset to force a new discovery</p>
          
          

          
          <div class="method-source-code" id="discover-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 501</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">discover</span>(<span class="ruby-identifier">flags</span>={})
  <span class="ruby-identifier">flags</span>.<span class="ruby-identifier">keys</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;Unknown option #{key} passed to discover&quot;</span> <span class="ruby-keyword">unless</span> [<span class="ruby-value">:verbose</span>, <span class="ruby-value">:hosts</span>, <span class="ruby-value">:nodes</span>, <span class="ruby-value">:json</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">flags</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-value">:verbose</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">verbose</span> = <span class="ruby-identifier">flags</span>[<span class="ruby-value">:verbose</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">verbose</span> = <span class="ruby-ivar">@verbose</span>

  <span class="ruby-identifier">verbose</span> = <span class="ruby-keyword">false</span> <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@output_format</span> <span class="ruby-operator">==</span> <span class="ruby-value">:console</span>

  <span class="ruby-comment"># flags[:nodes] and flags[:hosts] are the same thing, we should never have</span>
  <span class="ruby-comment"># allowed :hosts as that was inconsistent with the established terminology</span>
  <span class="ruby-identifier">flags</span>[<span class="ruby-value">:nodes</span>] = <span class="ruby-identifier">flags</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:hosts</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">flags</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-value">:hosts</span>)

  <span class="ruby-identifier">reset</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">flags</span>[<span class="ruby-value">:nodes</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">flags</span>[<span class="ruby-value">:json</span>]

  <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@discovered_agents</span>
    <span class="ruby-comment"># if either hosts or JSON is supplied try to figure out discovery data from there</span>
    <span class="ruby-comment"># if direct_addressing is not enabled this is a critical error as the user might</span>
    <span class="ruby-comment"># not have supplied filters so raise an exception</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">flags</span>[<span class="ruby-value">:nodes</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">flags</span>[<span class="ruby-value">:json</span>]
      <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;Can only supply discovery data if direct_addressing is enabled&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-constant">Config</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">direct_addressing</span>

      <span class="ruby-identifier">hosts</span> = []

      <span class="ruby-keyword">if</span> <span class="ruby-identifier">flags</span>[<span class="ruby-value">:nodes</span>]
        <span class="ruby-identifier">hosts</span> = <span class="ruby-constant">Helpers</span>.<span class="ruby-identifier">extract_hosts_from_array</span>(<span class="ruby-identifier">flags</span>[<span class="ruby-value">:nodes</span>])
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">flags</span>[<span class="ruby-value">:json</span>]
        <span class="ruby-identifier">hosts</span> = <span class="ruby-constant">Helpers</span>.<span class="ruby-identifier">extract_hosts_from_json</span>(<span class="ruby-identifier">flags</span>[<span class="ruby-value">:json</span>])
      <span class="ruby-keyword">end</span>

      <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;Could not find any hosts in discovery data provided&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">hosts</span>.<span class="ruby-identifier">empty?</span>

      <span class="ruby-ivar">@discovered_agents</span> = <span class="ruby-identifier">hosts</span>
      <span class="ruby-ivar">@force_direct_request</span> = <span class="ruby-keyword">true</span>

    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">identity_filter_discovery_optimization</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># All else fails we do it the hard way using a traditional broadcast</span>
  <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@discovered_agents</span>
    <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">time_discovery</span> <span class="ruby-value">:start</span>

    <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">options</span> = <span class="ruby-identifier">options</span>

    <span class="ruby-comment"># if compound filters are used the only real option is to use the mc</span>
    <span class="ruby-comment"># discovery plugin since its the only capable of using data queries etc</span>
    <span class="ruby-comment"># and we do not want to degrade that experience just to allow compounds</span>
    <span class="ruby-comment"># on other discovery plugins the UX would be too bad raising complex sets</span>
    <span class="ruby-comment"># of errors etc.</span>
    <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">discoverer</span>.<span class="ruby-identifier">force_discovery_method_by_filter</span>(<span class="ruby-identifier">options</span>[<span class="ruby-value">:filter</span>])

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">verbose</span>
      <span class="ruby-identifier">actual_timeout</span> = <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">discoverer</span>.<span class="ruby-identifier">discovery_timeout</span>(<span class="ruby-identifier">discovery_timeout</span>, <span class="ruby-identifier">options</span>[<span class="ruby-value">:filter</span>])

      <span class="ruby-keyword">if</span> <span class="ruby-identifier">actual_timeout</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
        <span class="ruby-ivar">@stderr</span>.<span class="ruby-identifier">print</span>(<span class="ruby-string">&quot;Discovering hosts using the %s method for %d second(s) .... &quot;</span> <span class="ruby-operator">%</span> [<span class="ruby-ivar">@client</span>.<span class="ruby-identifier">discoverer</span>.<span class="ruby-identifier">discovery_method</span>, <span class="ruby-identifier">actual_timeout</span>])
      <span class="ruby-keyword">else</span>
        <span class="ruby-ivar">@stderr</span>.<span class="ruby-identifier">print</span>(<span class="ruby-string">&quot;Discovering hosts using the %s method .... &quot;</span> <span class="ruby-operator">%</span> [<span class="ruby-ivar">@client</span>.<span class="ruby-identifier">discoverer</span>.<span class="ruby-identifier">discovery_method</span>])
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># if the requested limit is a pure number and not a percent</span>
    <span class="ruby-comment"># and if we&#39;re configured to use the first found hosts as the</span>
    <span class="ruby-comment"># limit method then pass in the limit thus minimizing the amount</span>
    <span class="ruby-comment"># of work we do in the discover phase and speeding it up significantly</span>
    <span class="ruby-identifier">filter</span> = <span class="ruby-ivar">@filter</span>.<span class="ruby-identifier">merge</span>({<span class="ruby-string">&#39;collective&#39;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@collective</span>})
    <span class="ruby-keyword">if</span> <span class="ruby-ivar">@limit_method</span> <span class="ruby-operator">==</span> <span class="ruby-value">:first</span> <span class="ruby-keyword">and</span> <span class="ruby-ivar">@limit_targets</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Integer</span>)
      <span class="ruby-ivar">@discovered_agents</span> = <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">discover</span>(<span class="ruby-identifier">filter</span>, <span class="ruby-identifier">discovery_timeout</span>, <span class="ruby-ivar">@limit_targets</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-ivar">@discovered_agents</span> = <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">discover</span>(<span class="ruby-identifier">filter</span>, <span class="ruby-identifier">discovery_timeout</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-ivar">@stderr</span>.<span class="ruby-identifier">puts</span>(<span class="ruby-ivar">@discovered_agents</span>.<span class="ruby-identifier">size</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">verbose</span>

    <span class="ruby-ivar">@force_direct_request</span> = <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">discoverer</span>.<span class="ruby-identifier">force_direct_mode?</span>

    <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">time_discovery</span> <span class="ruby-value">:end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">discovered_agents</span>(<span class="ruby-ivar">@discovered_agents</span>)
  <span class="ruby-constant">RPC</span>.<span class="ruby-identifier">discovered</span>(<span class="ruby-ivar">@discovered_agents</span>)

  <span class="ruby-ivar">@discovered_agents</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-discovery_method-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">discovery_method=</span><span
            class="method-args">(method)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Sets the discovery method.  If we change the method there are a number of
steps to take:</p>

<pre>- set the new method
- if discovery options were provided, re-set those to initially
  provided ones else clear them as they might now apply to a
  different provider
- update the client options so it knows there is a new discovery
  method in force
- reset discovery data forcing a discover on the next request</pre>

<p>The remaining item is the discovery timeout, we leave that as is since that
is the user supplied timeout either via initial options or via specifically
setting it on the client.</p>
          
          

          
          <div class="method-source-code" id="discovery_method-3D-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 392</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">discovery_method=</span>(<span class="ruby-identifier">method</span>)
  <span class="ruby-ivar">@default_discovery_method</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-ivar">@discovery_method</span> = <span class="ruby-identifier">method</span>

  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@initial_options</span>[<span class="ruby-value">:discovery_options</span>]
    <span class="ruby-ivar">@discovery_options</span> = <span class="ruby-ivar">@initial_options</span>[<span class="ruby-value">:discovery_options</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@discovery_options</span>.<span class="ruby-identifier">clear</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">options</span> = <span class="ruby-identifier">options</span>

  <span class="ruby-identifier">reset</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-discovery_options-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">discovery_options=</span><span
            class="method-args">(options)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="discovery_options-3D-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 407</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">discovery_options=</span>(<span class="ruby-identifier">options</span>)
  <span class="ruby-ivar">@discovery_options</span> = [<span class="ruby-identifier">options</span>].<span class="ruby-identifier">flatten</span>
  <span class="ruby-identifier">reset</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-discovery_timeout" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">discovery_timeout</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="discovery_timeout-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 359</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">discovery_timeout</span>
  <span class="ruby-keyword">return</span> <span class="ruby-ivar">@discovery_timeout</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@discovery_timeout</span>
  <span class="ruby-keyword">return</span> <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">discoverer</span>.<span class="ruby-identifier">ddl</span>.<span class="ruby-identifier">meta</span>[<span class="ruby-value">:timeout</span>]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-discovery_timeout-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">discovery_timeout=</span><span
            class="method-args">(timeout)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="discovery_timeout-3D-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 364</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">discovery_timeout=</span>(<span class="ruby-identifier">timeout</span>)
  <span class="ruby-ivar">@discovery_timeout</span> = <span class="ruby-constant">Float</span>(<span class="ruby-identifier">timeout</span>)

  <span class="ruby-comment"># we calculate the overall timeout from the DDL of the agent and</span>
  <span class="ruby-comment"># the supplied discovery timeout unless someone specifically</span>
  <span class="ruby-comment"># specifies a timeout to the constructor</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># But if we also then specifically set a discovery_timeout on the</span>
  <span class="ruby-comment"># agent that has to override the supplied timeout so we then</span>
  <span class="ruby-comment"># calculate a correct timeout based on DDL timeout and the</span>
  <span class="ruby-comment"># supplied discovery timeout</span>
  <span class="ruby-ivar">@timeout</span> = <span class="ruby-ivar">@ddl</span>.<span class="ruby-identifier">meta</span>[<span class="ruby-value">:timeout</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">discovery_timeout</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-fact_filter" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">fact_filter</span><span
            class="method-args">(fact, value=nil, operator="=")</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Sets the fact filter</p>
          
          

          
          <div class="method-source-code" id="fact_filter-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 420</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">fact_filter</span>(<span class="ruby-identifier">fact</span>, <span class="ruby-identifier">value</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">operator</span>=<span class="ruby-string">&quot;=&quot;</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">fact</span>.<span class="ruby-identifier">nil?</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">fact</span> <span class="ruby-operator">==</span> <span class="ruby-keyword">false</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">parsed</span> = <span class="ruby-constant">Util</span>.<span class="ruby-identifier">parse_fact_string</span>(<span class="ruby-identifier">fact</span>)
    <span class="ruby-ivar">@filter</span>[<span class="ruby-string">&quot;fact&quot;</span>] = <span class="ruby-ivar">@filter</span>[<span class="ruby-string">&quot;fact&quot;</span>] <span class="ruby-operator">|</span> [<span class="ruby-identifier">parsed</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">parsed</span> <span class="ruby-operator">==</span> <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">parsed</span> = <span class="ruby-constant">Util</span>.<span class="ruby-identifier">parse_fact_string</span>(<span class="ruby-node">&quot;#{fact}#{operator}#{value}&quot;</span>)
    <span class="ruby-ivar">@filter</span>[<span class="ruby-string">&quot;fact&quot;</span>] = <span class="ruby-ivar">@filter</span>[<span class="ruby-string">&quot;fact&quot;</span>] <span class="ruby-operator">|</span> [<span class="ruby-identifier">parsed</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">parsed</span> <span class="ruby-operator">==</span> <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-ivar">@filter</span>[<span class="ruby-string">&quot;fact&quot;</span>].<span class="ruby-identifier">compact!</span>
  <span class="ruby-identifier">reset</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-fire_and_forget_request" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">fire_and_forget_request</span><span
            class="method-args">(action, args, filter=nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>for requests that do not care for results just return the request id and
don&#39;t do any of the response processing.</p>

<p>We send the :process_results flag with to the nodes so they can make
decisions based on that.</p>

<p>Should only be called via <a
href="Client.html#method-i-method_missing">#method_missing</a></p>
          
          

          
          <div class="method-source-code" id="fire_and_forget_request-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 759</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">fire_and_forget_request</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">filter</span>=<span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">validate_request</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>)

  <span class="ruby-identifier">identity_filter_discovery_optimization</span>

  <span class="ruby-identifier">req</span> = <span class="ruby-identifier">new_request</span>(<span class="ruby-identifier">action</span>.<span class="ruby-identifier">to_s</span>, <span class="ruby-identifier">args</span>)

  <span class="ruby-identifier">filter</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:filter</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">filter</span>

  <span class="ruby-identifier">message</span> = <span class="ruby-constant">Message</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">req</span>, <span class="ruby-keyword">nil</span>, {<span class="ruby-value">:agent</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@agent</span>, <span class="ruby-value">:type</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:request</span>, <span class="ruby-value">:collective</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@collective</span>, <span class="ruby-value">:filter</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">filter</span>, <span class="ruby-value">:options</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">options</span>})
  <span class="ruby-identifier">message</span>.<span class="ruby-identifier">reply_to</span> = <span class="ruby-ivar">@reply_to</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@reply_to</span>

  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@force_direct_request</span> <span class="ruby-operator">||</span> <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">discoverer</span>.<span class="ruby-identifier">force_direct_mode?</span>
    <span class="ruby-identifier">message</span>.<span class="ruby-identifier">discovered_hosts</span> = <span class="ruby-identifier">discover</span>.<span class="ruby-identifier">clone</span>
    <span class="ruby-identifier">message</span>.<span class="ruby-identifier">type</span> = <span class="ruby-value">:direct_request</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">client</span>.<span class="ruby-identifier">sendreq</span>(<span class="ruby-identifier">message</span>, <span class="ruby-keyword">nil</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-help" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">help</span><span
            class="method-args">(template)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns help for an agent if a <a href="../DDL.html">DDL</a> was found</p>
          
          

          
          <div class="method-source-code" id="help-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">help</span>(<span class="ruby-identifier">template</span>)
  <span class="ruby-ivar">@ddl</span>.<span class="ruby-identifier">help</span>(<span class="ruby-identifier">template</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-identity_filter" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">identity_filter</span><span
            class="method-args">(identity)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Sets the identity filter</p>
          
          

          
          <div class="method-source-code" id="identity_filter-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 444</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">identity_filter</span>(<span class="ruby-identifier">identity</span>)
  <span class="ruby-ivar">@filter</span>[<span class="ruby-string">&quot;identity&quot;</span>] = <span class="ruby-ivar">@filter</span>[<span class="ruby-string">&quot;identity&quot;</span>] <span class="ruby-operator">|</span> [<span class="ruby-identifier">identity</span>]
  <span class="ruby-ivar">@filter</span>[<span class="ruby-string">&quot;identity&quot;</span>].<span class="ruby-identifier">compact!</span>
  <span class="ruby-identifier">reset</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-identity_filter_discovery_optimization" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">identity_filter_discovery_optimization</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>if an identity filter is supplied and it is all strings no regex we can use
that as discovery data, technically the identity filter is then redundant
if we are in direct addressing mode and we could empty it out but this use
case should only really be for a few -I&#39;s on the CLI</p>

<p>For safety we leave the filter in place for now, that way we can support
this enhancement also in broadcast mode.</p>

<p>This is only needed for the &#39;mc&#39; discovery method, other methods
might change the concept of identity to mean something else so we should
pass the full identity filter to them</p>
          
          

          
          <div class="method-source-code" id="identity_filter_discovery_optimization-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 790</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">identity_filter_discovery_optimization</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:filter</span>][<span class="ruby-string">&quot;identity&quot;</span>].<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-ivar">@discovery_method</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;mc&quot;</span>
    <span class="ruby-identifier">regex_filters</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:filter</span>][<span class="ruby-string">&quot;identity&quot;</span>].<span class="ruby-identifier">select</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">i</span>.<span class="ruby-identifier">match</span>(<span class="ruby-string">&quot;^\/&quot;</span>)}.<span class="ruby-identifier">size</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">regex_filters</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
      <span class="ruby-ivar">@discovered_agents</span> = <span class="ruby-identifier">options</span>[<span class="ruby-value">:filter</span>][<span class="ruby-string">&quot;identity&quot;</span>].<span class="ruby-identifier">clone</span>
      <span class="ruby-ivar">@force_direct_request</span> = <span class="ruby-keyword">true</span> <span class="ruby-keyword">if</span> <span class="ruby-constant">Config</span>.<span class="ruby-identifier">instance</span>.<span class="ruby-identifier">direct_addressing</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-limit_method-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">limit_method=</span><span
            class="method-args">(method)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Sets and sanity check the <a
href="Client.html#attribute-i-limit_method">#limit_method</a> variable used
to determine how to limit targets if <a
href="Client.html#attribute-i-limit_targets">#limit_targets</a> is set</p>
          
          

          
          <div class="method-source-code" id="limit_method-3D-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 639</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">limit_method=</span>(<span class="ruby-identifier">method</span>)
  <span class="ruby-identifier">method</span> = <span class="ruby-identifier">method</span>.<span class="ruby-identifier">to_sym</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">method</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Symbol</span>)

  <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;Unknown limit method #{method} must be :random or :first&quot;</span> <span class="ruby-keyword">unless</span> [<span class="ruby-value">:random</span>, <span class="ruby-value">:first</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">method</span>)

  <span class="ruby-ivar">@limit_method</span> = <span class="ruby-identifier">method</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-limit_targets-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">limit_targets=</span><span
            class="method-args">(limit)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Sets and sanity checks the <a
href="Client.html#attribute-i-limit_targets">#limit_targets</a> variable
used to restrict how many nodes we&#39;ll target Limit targets can be reset
by passing nil or false</p>
          
          

          
          <div class="method-source-code" id="limit_targets-3D-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 618</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">limit_targets=</span>(<span class="ruby-identifier">limit</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">limit</span>
    <span class="ruby-ivar">@limit_targets</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">return</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">limit</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">String</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;Invalid limit specified: #{limit} valid limits are /^\d+%*$/&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">limit</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/^\d+%*$/</span>

    <span class="ruby-keyword">begin</span>
      <span class="ruby-ivar">@limit_targets</span> = <span class="ruby-constant">Integer</span>(<span class="ruby-identifier">limit</span>)
    <span class="ruby-keyword">rescue</span>
      <span class="ruby-ivar">@limit_targets</span> = <span class="ruby-identifier">limit</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@limit_targets</span> = <span class="ruby-constant">Integer</span>(<span class="ruby-identifier">limit</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-load_aggregate_functions" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">load_aggregate_functions</span><span
            class="method-args">(action, ddl)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="load_aggregate_functions-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 720</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">load_aggregate_functions</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">ddl</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">ddl</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">ddl</span>.<span class="ruby-identifier">action_interface</span>(<span class="ruby-identifier">action</span>).<span class="ruby-identifier">keys</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-value">:aggregate</span>)

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Aggregate</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">ddl</span>.<span class="ruby-identifier">action_interface</span>(<span class="ruby-identifier">action</span>))

<span class="ruby-keyword">rescue</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>
  <span class="ruby-constant">Log</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&quot;Failed to load aggregate functions, calculating summaries disabled: %s: %s (%s)&quot;</span> <span class="ruby-operator">%</span> [<span class="ruby-identifier">e</span>.<span class="ruby-identifier">backtrace</span>.<span class="ruby-identifier">first</span>, <span class="ruby-identifier">e</span>.<span class="ruby-identifier">to_s</span>, <span class="ruby-identifier">e</span>.<span class="ruby-identifier">class</span>])
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-method_missing" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">method_missing</span><span
            class="method-args">(method_name, *args, &block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Magic handler to invoke remote methods</p>

<p>Once the stub is created using the constructor or the <a
href="../RPC.html#method-i-rpcclient">MCollective::RPC#rpcclient</a> helper
you can call remote actions easily:</p>

<pre class="ruby"><span class="ruby-identifier">ret</span> = <span class="ruby-identifier">rpc</span>.<span class="ruby-identifier">echo</span>(:<span class="ruby-identifier">msg</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;hello world&quot;</span>)
</pre>

<p>This will call the &#39;echo&#39; action of the &#39;rpctest&#39; agent and
return the result as an array, the array will be a simplified result set
from the usual full <a
href="../Client.html#method-i-req">MCollective::Client#req</a> with
additional error codes and error text:</p>

<p>{</p>

<pre>:sender =&gt; &quot;remote.box.com&quot;,
:statuscode =&gt; 0,
:statusmsg =&gt; &quot;OK&quot;,
:data =&gt; &quot;hello world&quot;</pre>

<p>}</p>

<p>If :statuscode is 0 then everything went find, if it&#39;s 1 then you
supplied the correct arguments etc but the request could not be completed,
you&#39;ll find a human parsable reason in :statusmsg then.</p>

<p>Codes 2 to 5 maps directly to <a
href="../UnknownRPCAction.html">UnknownRPCAction</a>, <a
href="../MissingRPCData.html">MissingRPCData</a>, <a
href="../InvalidRPCData.html">InvalidRPCData</a> and <a
href="../UnknownRPCError.html">UnknownRPCError</a> see below for a
description of those, in each case :statusmsg would be the reason for
failure.</p>

<p>To get access to the full result of the <a
href="../Client.html#method-i-req">MCollective::Client#req</a> calls you
can pass in a block:</p>

<pre class="ruby"><span class="ruby-identifier">rpc</span>.<span class="ruby-identifier">echo</span>(:<span class="ruby-identifier">msg</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;hello world&quot;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">resp</span><span class="ruby-operator">|</span>
   <span class="ruby-identifier">pp</span> <span class="ruby-identifier">resp</span>
<span class="ruby-keyword">end</span>
</pre>

<p>In this case resp will the result from <a
href="../Client.html#method-i-req">MCollective::Client#req</a>.  Instead of
returning simple text and codes as above you&#39;ll also need to handle the
following exceptions:</p>

<p><a href="../UnknownRPCAction.html">UnknownRPCAction</a> - There is no
matching action on the agent <a
href="../MissingRPCData.html">MissingRPCData</a> - You did not supply all
the needed parameters for the action <a
href="../InvalidRPCData.html">InvalidRPCData</a> - The data you did supply
did not pass validation <a
href="../UnknownRPCError.html">UnknownRPCError</a> - Some other error
prevented the agent from running</p>

<p>During calls a progress indicator will be shown of how many results
we&#39;ve received against how many nodes were discovered, you can disable
this by setting progress to false:</p>

<pre class="ruby"><span class="ruby-identifier">rpc</span>.<span class="ruby-identifier">progress</span> = <span class="ruby-keyword">false</span>
</pre>

<p>This supports a 2nd mode where it will send the SimpleRPC request and never
handle the responses.  It&#39;s a bit like UDP, it sends the request with
the filter attached and you only get back the requestid, you have no
indication about results.</p>

<p>You can invoke this using:</p>

<pre class="ruby"><span class="ruby-identifier">puts</span> <span class="ruby-identifier">rpc</span>.<span class="ruby-identifier">echo</span>(:<span class="ruby-identifier">process_results</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span>)
</pre>

<p>This will output just the request id.</p>

<p>Batched processing is supported:</p>

<pre class="ruby"><span class="ruby-identifier">printrpc</span> <span class="ruby-identifier">rpc</span>.<span class="ruby-identifier">ping</span>(:<span class="ruby-identifier">batch_size</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">5</span>)
</pre>

<p>This will do everything exactly as normal but communicate to only 5 agents
at a time</p>
          
          

          
          <div class="method-source-code" id="method_missing-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 241</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">method_missing</span>(<span class="ruby-identifier">method_name</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-comment"># set args to an empty hash if nothings given</span>
  <span class="ruby-identifier">args</span> = <span class="ruby-identifier">args</span>[<span class="ruby-value">0</span>]
  <span class="ruby-identifier">args</span> = {} <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">nil?</span>

  <span class="ruby-identifier">action</span> = <span class="ruby-identifier">method_name</span>.<span class="ruby-identifier">to_s</span>

  <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">reset</span>

  <span class="ruby-identifier">validate_request</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>)

  <span class="ruby-comment"># TODO(ploubser): The logic here seems poor. It implies that it is valid to</span>
  <span class="ruby-comment"># pass arguments where batch_mode is set to false and batch_mode &gt; 0.</span>
  <span class="ruby-comment"># If this is the case we completely ignore the supplied value of batch_mode</span>
  <span class="ruby-comment"># and do our own thing.</span>

  <span class="ruby-comment"># if a global batch size is set just use that else set it</span>
  <span class="ruby-comment"># in the case that it was passed as an argument</span>
  <span class="ruby-identifier">batch_mode</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-value">:batch_size</span>) <span class="ruby-operator">||</span> <span class="ruby-ivar">@batch_mode</span>
  <span class="ruby-identifier">batch_size</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:batch_size</span>) <span class="ruby-operator">||</span> <span class="ruby-ivar">@batch_size</span>
  <span class="ruby-identifier">batch_sleep_time</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:batch_sleep_time</span>) <span class="ruby-operator">||</span> <span class="ruby-ivar">@batch_sleep_time</span>

  <span class="ruby-comment"># if we were given a batch_size argument thats 0 and batch_mode was</span>
  <span class="ruby-comment"># determined to be on via global options etc this will allow a batch_size</span>
  <span class="ruby-comment"># of 0 to disable or batch_mode for this call only</span>
  <span class="ruby-identifier">batch_mode</span> = <span class="ruby-identifier">determine_batch_mode</span>(<span class="ruby-identifier">batch_size</span>)

  <span class="ruby-comment"># Handle single target requests by doing discovery and picking</span>
  <span class="ruby-comment"># a random node.  Then do a custom request specifying a filter</span>
  <span class="ruby-comment"># that will only match the one node.</span>
  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@limit_targets</span>
    <span class="ruby-identifier">target_nodes</span> = <span class="ruby-identifier">pick_nodes_from_discovered</span>(<span class="ruby-ivar">@limit_targets</span>)
    <span class="ruby-constant">Log</span>.<span class="ruby-identifier">debug</span>(<span class="ruby-node">&quot;Picked #{target_nodes.join(&#39;,&#39;)} as limited target(s)&quot;</span>)

    <span class="ruby-identifier">custom_request</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">target_nodes</span>, {<span class="ruby-string">&quot;identity&quot;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-node">/^(#{target_nodes.join(&#39;|&#39;)})$/</span>}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">batch_mode</span>
    <span class="ruby-identifier">call_agent_batched</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">options</span>, <span class="ruby-identifier">batch_size</span>, <span class="ruby-identifier">batch_sleep_time</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">call_agent</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>, <span class="ruby-identifier">options</span>, <span class="ruby-value">:auto</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-new_request" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new_request</span><span
            class="method-args">(action, data)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Creates a suitable request hash for the SimpleRPC agent.</p>

<p>You&#39;d use this if you ever wanted to take care of sending requests on
your own - perhaps via Client#sendreq if you didn&#39;t care for responses.</p>

<p>In that case you can just do:</p>

<pre class="ruby"><span class="ruby-identifier">msg</span> = <span class="ruby-identifier">your_rpc</span>.<span class="ruby-identifier">new_request</span>(<span class="ruby-string">&quot;some_action&quot;</span>, :<span class="ruby-identifier">foo</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">bar</span>)
<span class="ruby-identifier">filter</span> = <span class="ruby-identifier">your_rpc</span>.<span class="ruby-identifier">filter</span>

<span class="ruby-identifier">your_rpc</span>.<span class="ruby-identifier">client</span>.<span class="ruby-identifier">sendreq</span>(<span class="ruby-identifier">msg</span>, <span class="ruby-identifier">msg</span>[:<span class="ruby-identifier">agent</span>], <span class="ruby-identifier">filter</span>)
</pre>

<p>This will send a SimpleRPC request to the action some_action with arguments
:foo = :bar, it will return immediately and you will have no indication at
all if the request was receieved or not</p>

<p>Clearly the use of this technique should be limited and done only if your
code requires such a thing</p>
          
          

          
          <div class="method-source-code" id="new_request-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">new_request</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">data</span>)
  <span class="ruby-identifier">callerid</span> = <span class="ruby-constant">PluginManager</span>[<span class="ruby-string">&quot;security_plugin&quot;</span>].<span class="ruby-identifier">callerid</span>

  <span class="ruby-identifier">raise</span> <span class="ruby-string">&#39;callerid received from security plugin is not valid&#39;</span> <span class="ruby-keyword">unless</span> <span class="ruby-constant">PluginManager</span>[<span class="ruby-string">&quot;security_plugin&quot;</span>].<span class="ruby-identifier">valid_callerid?</span>(<span class="ruby-identifier">callerid</span>)

  {<span class="ruby-value">:agent</span>  =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@agent</span>,
   <span class="ruby-value">:action</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">action</span>,
   <span class="ruby-value">:caller</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">callerid</span>,
   <span class="ruby-value">:data</span>   =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">data</span>}
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-options" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">options</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Provides a normal options hash like you would get from <a
href="../Optionparser.html">Optionparser</a></p>
          
          

          
          <div class="method-source-code" id="options-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 590</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">options</span>
  {<span class="ruby-value">:disctimeout</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">discovery_timeout</span>,
   <span class="ruby-value">:timeout</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@timeout</span>,
   <span class="ruby-value">:verbose</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@verbose</span>,
   <span class="ruby-value">:filter</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@filter</span>,
   <span class="ruby-value">:collective</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@collective</span>,
   <span class="ruby-value">:output_format</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@output_format</span>,
   <span class="ruby-value">:ttl</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@ttl</span>,
   <span class="ruby-value">:discovery_method</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@discovery_method</span>,
   <span class="ruby-value">:discovery_options</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@discovery_options</span>,
   <span class="ruby-value">:force_display_mode</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@force_display_mode</span>,
   <span class="ruby-value">:config</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@config</span>,
   <span class="ruby-value">:publish_timeout</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@publish_timeout</span>,
   <span class="ruby-value">:threaded</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@threaded</span>}
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-pick_nodes_from_discovered" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">pick_nodes_from_discovered</span><span
            class="method-args">(count)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Pick a number of nodes from the discovered nodes</p>

<p>The count should be a string that can be either just a number or a
percentage like 10%</p>

<p>It will select nodes from the discovered list based on the rpclimitmethod
configuration option which can be either :first or anything else</p>

<pre>- :first would be a simple way to do a distance based
  selection
- anything else will just pick one at random
- if random chosen, and batch-seed set, then set srand
  for the generator, and reset afterwards</pre>
          
          

          
          <div class="method-source-code" id="pick_nodes_from_discovered-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 679</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">pick_nodes_from_discovered</span>(<span class="ruby-identifier">count</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">count</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/%$/</span>
    <span class="ruby-identifier">pct</span> = <span class="ruby-constant">Integer</span>((<span class="ruby-identifier">discover</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">*</span> (<span class="ruby-identifier">count</span>.<span class="ruby-identifier">to_f</span> <span class="ruby-operator">/</span> <span class="ruby-value">100</span>)))
    <span class="ruby-identifier">pct</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">count</span> = <span class="ruby-value">1</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">count</span> = <span class="ruby-identifier">pct</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">count</span> = <span class="ruby-constant">Integer</span>(<span class="ruby-identifier">count</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">discover</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">discover</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">count</span>

  <span class="ruby-identifier">result</span> = []

  <span class="ruby-keyword">if</span> <span class="ruby-ivar">@limit_method</span> <span class="ruby-operator">==</span> <span class="ruby-value">:first</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">discover</span>[<span class="ruby-value">0</span>, <span class="ruby-identifier">count</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-comment"># we delete from the discovered list because we want</span>
    <span class="ruby-comment"># to be sure there is no chance that the same node will</span>
    <span class="ruby-comment"># be randomly picked twice.  So we have to clone the</span>
    <span class="ruby-comment"># discovered list else this method will only ever work</span>
    <span class="ruby-comment"># once per discovery cycle and not actually return the</span>
    <span class="ruby-comment"># right nodes.</span>
    <span class="ruby-identifier">haystack</span> = <span class="ruby-identifier">discover</span>.<span class="ruby-identifier">clone</span>

    <span class="ruby-keyword">if</span> <span class="ruby-ivar">@limit_seed</span>
      <span class="ruby-identifier">haystack</span>.<span class="ruby-identifier">sort!</span>
      <span class="ruby-identifier">srand</span>(<span class="ruby-ivar">@limit_seed</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">count</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span>
      <span class="ruby-identifier">rnd</span> = <span class="ruby-identifier">rand</span>(<span class="ruby-identifier">haystack</span>.<span class="ruby-identifier">size</span>)
      <span class="ruby-identifier">result</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">haystack</span>.<span class="ruby-identifier">delete_at</span>(<span class="ruby-identifier">rnd</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># Reset random number generator to fresh seed</span>
    <span class="ruby-comment"># As our seed from options is most likely short</span>
    <span class="ruby-identifier">srand</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@limit_seed</span>
  <span class="ruby-keyword">end</span>

  [<span class="ruby-identifier">result</span>].<span class="ruby-identifier">flatten</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-process_results_with_block" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">process_results_with_block</span><span
            class="method-args">(action, resp, block, aggregate)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>process client requests by calling a block on each result in this mode we
do not do anything fancy with the result objects and we raise exceptions if
there are problems with the data</p>
          
          

          
          <div class="method-source-code" id="process_results_with_block-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 1017</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">process_results_with_block</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">resp</span>, <span class="ruby-identifier">block</span>, <span class="ruby-identifier">aggregate</span>)
  <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">node_responded</span>(<span class="ruby-identifier">resp</span>[<span class="ruby-value">:senderid</span>])

  <span class="ruby-identifier">result</span> = <span class="ruby-identifier">rpc_result_from_reply</span>(<span class="ruby-ivar">@agent</span>, <span class="ruby-identifier">action</span>, <span class="ruby-identifier">resp</span>)
  <span class="ruby-identifier">aggregate</span> = <span class="ruby-identifier">aggregate_reply</span>(<span class="ruby-identifier">result</span>, <span class="ruby-identifier">aggregate</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">aggregate</span>

  <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">ok</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">result</span>[<span class="ruby-value">:statuscode</span>] <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
  <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">fail</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">result</span>[<span class="ruby-value">:statuscode</span>] <span class="ruby-operator">!=</span> <span class="ruby-value">0</span>
  <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">time_block_execution</span> <span class="ruby-value">:start</span>

  <span class="ruby-keyword">case</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">arity</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">1</span>
      <span class="ruby-identifier">block</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">resp</span>)
    <span class="ruby-keyword">when</span> <span class="ruby-value">2</span>
      <span class="ruby-identifier">block</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">resp</span>, <span class="ruby-identifier">result</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">time_block_execution</span> <span class="ruby-value">:end</span>

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">aggregate</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-process_results_without_block" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">process_results_without_block</span><span
            class="method-args">(resp, action, aggregate)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Handles result sets that has no block associated, sets fails and ok in the
stats object and return a hash of the response to send to the caller</p>
          
          

          
          <div class="method-source-code" id="process_results_without_block-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 997</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">process_results_without_block</span>(<span class="ruby-identifier">resp</span>, <span class="ruby-identifier">action</span>, <span class="ruby-identifier">aggregate</span>)
  <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">node_responded</span>(<span class="ruby-identifier">resp</span>[<span class="ruby-value">:senderid</span>])

  <span class="ruby-identifier">result</span> = <span class="ruby-identifier">rpc_result_from_reply</span>(<span class="ruby-ivar">@agent</span>, <span class="ruby-identifier">action</span>, <span class="ruby-identifier">resp</span>)
  <span class="ruby-identifier">aggregate</span> = <span class="ruby-identifier">aggregate_reply</span>(<span class="ruby-identifier">result</span>, <span class="ruby-identifier">aggregate</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">aggregate</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">result</span>[<span class="ruby-value">:statuscode</span>] <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">result</span>[<span class="ruby-value">:statuscode</span>] <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
    <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">ok</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">result</span>[<span class="ruby-value">:statuscode</span>] <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
    <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">fail</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">result</span>[<span class="ruby-value">:statuscode</span>] <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@stats</span>.<span class="ruby-identifier">fail</span>
  <span class="ruby-keyword">end</span>

  [<span class="ruby-identifier">result</span>, <span class="ruby-identifier">aggregate</span>]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reset" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">reset</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Resets various internal parts of the class, most importantly it clears out
the cached discovery</p>
          
          

          
          <div class="method-source-code" id="reset-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 458</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">reset</span>
  <span class="ruby-ivar">@discovered_agents</span> = <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reset_filter" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">reset_filter</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Reet the filter to an empty one</p>
          
          

          
          <div class="method-source-code" id="reset_filter-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 463</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">reset_filter</span>
  <span class="ruby-ivar">@filter</span> = <span class="ruby-constant">Util</span>.<span class="ruby-identifier">empty_filter</span>
  <span class="ruby-identifier">agent_filter</span> <span class="ruby-ivar">@agent</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-rpc_result_from_reply" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">rpc_result_from_reply</span><span
            class="method-args">(agent, action, reply)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="rpc_result_from_reply-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 741</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">rpc_result_from_reply</span>(<span class="ruby-identifier">agent</span>, <span class="ruby-identifier">action</span>, <span class="ruby-identifier">reply</span>)
  <span class="ruby-identifier">senderid</span> = <span class="ruby-identifier">reply</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">&quot;senderid&quot;</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">reply</span>[<span class="ruby-string">&quot;senderid&quot;</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">reply</span>[<span class="ruby-value">:senderid</span>]
  <span class="ruby-identifier">body</span> = <span class="ruby-identifier">reply</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">&quot;body&quot;</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">reply</span>[<span class="ruby-string">&quot;body&quot;</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">reply</span>[<span class="ruby-value">:body</span>]
  <span class="ruby-identifier">s_code</span> = <span class="ruby-identifier">body</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">&quot;statuscode&quot;</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">body</span>[<span class="ruby-string">&quot;statuscode&quot;</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">body</span>[<span class="ruby-value">:statuscode</span>]
  <span class="ruby-identifier">s_msg</span> = <span class="ruby-identifier">body</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">&quot;statusmsg&quot;</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">body</span>[<span class="ruby-string">&quot;statusmsg&quot;</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">body</span>[<span class="ruby-value">:statusmsg</span>]
  <span class="ruby-identifier">data</span> = <span class="ruby-identifier">body</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">&quot;data&quot;</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">body</span>[<span class="ruby-string">&quot;data&quot;</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">body</span>[<span class="ruby-value">:data</span>]

  <span class="ruby-constant">Result</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">agent</span>, <span class="ruby-identifier">action</span>, {<span class="ruby-value">:sender</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">senderid</span>, <span class="ruby-value">:statuscode</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">s_code</span>, <span class="ruby-value">:statusmsg</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">s_msg</span>, <span class="ruby-value">:data</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">data</span>})
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-validate_request" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">validate_request</span><span
            class="method-args">(action, args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>For the provided arguments and action the input arguments get modified by
supplying any defaults provided in the <a href="../DDL.html">DDL</a> for
arguments that were not supplied in the request</p>

<p>We then pass the modified arguments to the <a href="../DDL.html">DDL</a>
for validation</p>
          
          

          
          <div class="method-source-code" id="validate_request-source">
            <pre><span class="ruby-comment"># File lib/mcollective/rpc/client.rb, line 175</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">validate_request</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;No DDL found for agent %s cannot validate inputs&quot;</span> <span class="ruby-operator">%</span> <span class="ruby-ivar">@agent</span> <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@ddl</span>

  <span class="ruby-ivar">@ddl</span>.<span class="ruby-identifier">set_default_input_arguments</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>)
  <span class="ruby-ivar">@ddl</span>.<span class="ruby-identifier">validate_rpc_request</span>(<span class="ruby-identifier">action</span>, <span class="ruby-identifier">args</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

